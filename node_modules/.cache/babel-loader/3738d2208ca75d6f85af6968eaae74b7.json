{"ast":null,"code":"\"use strict\";\n/* eslint-disable @typescript-eslint/ban-types */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useMergedClasses = exports.mergeClasses = void 0;\n\nconst objectKeys_1 = require(\"./tools/objectKeys\");\n\nconst getDependencyArrayRef_1 = require(\"./tools/getDependencyArrayRef\");\n\nconst cssAndCx_1 = require(\"./cssAndCx\");\n\nconst react_1 = require(\"react\");\n\nfunction mergeClasses(classesFromUseStyles, classesFromProps, cx) {\n  //NOTE: We use this test to be resilient in case classesFromProps is not of the expected type.\n  if (!(classesFromProps instanceof Object)) {\n    return classesFromUseStyles;\n  }\n\n  const out = {};\n  (0, objectKeys_1.objectKeys)(classesFromUseStyles).forEach(ruleName => out[ruleName] = cx(classesFromUseStyles[ruleName], classesFromProps[ruleName]));\n  (0, objectKeys_1.objectKeys)(classesFromProps).forEach(ruleName => {\n    if (ruleName in classesFromUseStyles) {\n      return;\n    }\n\n    const className = classesFromProps[ruleName]; //...Same here, that why we don't do className === undefined\n\n    if (typeof className !== \"string\") {\n      return;\n    }\n\n    out[ruleName] = className;\n  });\n  return out;\n}\n\nexports.mergeClasses = mergeClasses;\n\nfunction useMergedClasses(classes, classesOv) {\n  const {\n    cx\n  } = (0, cssAndCx_1.useCssAndCx)();\n  return (0, react_1.useMemo)(() => mergeClasses(classes, classesOv, cx), [classes, (0, getDependencyArrayRef_1.getDependencyArrayRef)(classesOv), cx]);\n}\n\nexports.useMergedClasses = useMergedClasses;","map":null,"metadata":{},"sourceType":"script"}